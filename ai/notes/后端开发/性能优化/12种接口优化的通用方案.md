# 12种接口优化的通用方案



## 一句话总结

接口性能优化的12种通用方案：批处理、异步处理、缓存、预处理、池化、并行化、索引优化、事务控制、代码重构、深分页优化、SQL优化和锁粒度控制。

---

## 核心要点

1. **批处理** - 批量操作数据库，减少IO次数
2. **异步处理** - 非关键逻辑异步执行，降低接口耗时
3. **空间换时间** - 合理使用缓存，避免重复计算
4. **预处理** - 提前计算结果，直接取用
5. **池化思想** - 预分配与循环使用，避免重复创建
6. **串行改并行** - 无依赖的任务并行执行
7. **索引优化** - 合理创建索引，提高查询效率
8. **避免大事务** - 防止数据库连接长时间占用
9. **优化程序结构** - 消除重复查询、重复创建对象
10. **深分页优化** - 使用id范围查询替代limit深分页
11. **SQL优化** - 结合索引、分页等优化查询
12. **锁粒度控制** - 只在临界资源处加锁

---

## 详细内容

### 1. 批处理

批量操作数据库，避免多次IO。

```
逐条插入：                    批量插入：
Insert 1 ──IO──→ DB          
Insert 2 ──IO──→ DB          Batch Insert ──IO──→ DB
Insert 3 ──IO──→ DB          
   ...                        N条数据 1次IO
Insert N ──IO──→ DB          
N次IO
```

代码示例：
```java
batchInsert();  // 批量入库
```

---

### 2. 异步处理

针对耗时较长且不是结果必须的逻辑，放到异步执行。

**场景**：理财申购接口，入账和写入申购文件是T+1交易，非实时必需。

```
同步模式：                              异步模式：
                                        
接口请求                                接口请求
   │                                       │
   ▼                                       ▼
申购操作 ←── 返回                       申购操作 ←── 立即返回
   │                                       │
入账（同步）                              ┌──────────┐
   │                                      │  入账     │───┐
写入文件（同步）                          │  写文件   │───┘
   │                                      └──────────┘
返回结果                                    │
                                         返回结果

耗时 = 申购+入账+写文件                  耗时 = 申购（毫秒级）
```

实现方式：线程池、消息队列、调度任务框架。

---

### 3. 空间换时间（缓存）

合理使用缓存，避免频繁查询数据库或重复计算。

**场景**：股票工具策略轮动查询，每周只更新一次。

```
无缓存：                              有缓存：
                                      
调接口                                  调接口
   │                                      │
   ▼                                      ▼
查数据库                                查缓存？
   │                                ┌────┴────┐
复杂计算                             命中     未命中
   │                                直接返回  查DB+计算+写缓存
计算结果
   │
返回结果

每次都要：查库+计算                  每周计算一次，之后查缓存
```

缓存选择：R2M、本地缓存、Memcached、Map。

注意：需权衡数据一致性问题。

---

### 4. 预处理

提前把数据计算好，使用时直接取用。

**场景**：理财产品年化收益率展示。

```
实时计算：                          预处理：
                                    
接口调用时：                        每日净值更新时：
净值→计算公式→年化收益率            净值→计算公式→存入字段
                                        ▲
                                        │
接口调用时：                          │
直接读取字段 ◄────────────────────────┘
```

与缓存的区别：预处理存到数据库字段，缓存存到内存。

---

### 5. 池化思想

预分配与循环使用，避免重复创建销毁。

常见应用：
- 数据库连接池
- 线程池
- 对象池

本质：创建和销毁也有开销，池化可以复用。

---

### 6. 串行改并行

无依赖的任务并行执行，降低总耗时。

**场景**：理财持仓页需要查询账户信息、商品信息、banner位信息。

```
串行模式：                              并行模式：
                                        
查询账户信息 ──100ms──→                
                         并行查询       账户信息 100ms
查询商品信息 ──80ms──→                 商品信息 80ms
                         ────┬───→     banner 50ms
查询banner位 ──50ms──→        │
                              │
组装返回                      组装返回
                              
总耗时：230ms                   总耗时：100ms（取最大值）
```

前提：任务之间无结果参数依赖。

---

### 7. 索引优化

通过索引提高数据查询效率。

**索引不生效的常见场景：**

| 场景 | 错误示例 | 正确示例 |
|------|---------|---------|
| 使用函数 | WHERE YEAR(time)=2024 | WHERE time >= '2024-01-01' |
| 隐式转换 | WHERE id = '123' | WHERE id = 123 |
| LIKE %开头 | WHERE name LIKE '%张%' | WHERE name LIKE '张%' |
| OR一边无索引 | WHERE id=1 OR name='张三' | 避免使用 |
| 使用!= | WHERE status != 0 | 避免使用 |
| 违反最左前缀 | 索引(a,b,c) 查b,c | 索引(a,b,c) 查a或a,b |

---

### 8. 避免大事务

防止事务长时间不提交导致数据库连接被占用。

**问题代码：**
```java
@Transactional
public BasicResult purchase(PurchaseRecord record) {
    // 业务逻辑
    pushRpc.doPush(record);  // RPC调用在事务内 ❌
    return result;
}
```

**优化方案：**
```
问题模式：                       优化模式：
                                  
开启事务                         开启事务
   │                                │
业务逻辑A                         业务逻辑A
   │                                │
业务逻辑B                         业务逻辑B
   │                                │
RPC调用  ──┐                     提交事务
业务逻辑C ──┤  耗时久，占用连接      │
           │                     RPC调用（移出事务）
提交事务 ───┘                     其他逻辑
```

规避方案：
1. RPC调用不放事务里
2. 查询操作放事务外
3. 事务中避免处理太多数据

---

### 9. 优化程序结构

重构代码，消除重复查询、重复创建对象。

常见问题：
- 重复查询同一数据
- 多次创建相同对象
- 需求迭代导致的代码叠加

解决方案：接口整体重构，评估每个代码块作用，调整执行顺序。

---

### 10. 深分页问题

避免使用limit深分页导致性能问题。

**问题SQL：**
```sql
-- 深分页 - 性能差
SELECT * FROM purchase_record 
WHERE productCode = 'PA9044' 
LIMIT 100000, 200;

-- 优化 - 使用id范围
SELECT * FROM purchase_record 
WHERE productCode = 'PA9044' 
AND id > 100000 
LIMIT 200;
```

对比：
- 深分页：扫描100200行，性能随页数下降
- id范围：扫描200行，性能稳定

局限：需要连续自增字段。

---

### 11. SQL优化

优化SQL语句提高查询性能。

优化方向：
- 避免SELECT *，只查需要的字段
- 避免子查询，使用JOIN
- 避免大表JOIN
- 使用EXPLAIN分析执行计划
- 合理使用索引

---

### 12. 锁粒度避免过粗

只在临界资源处加锁，避免锁范围过大。

**类比：**
- 错误：上卫生间把客厅、房间门都锁上
- 正确：只锁卫生间门

**代码示例：**

```java
// 错误：锁范围过大
synchronized (this) {
    notShare();  // 非共享资源 - 不需要锁
    share();     // 共享资源
}

// 正确：只在临界资源处加锁
notShare();     // 无锁
synchronized (this) {
    share();    // 加锁
}
```

---

## 总结与思考

**性能问题形成原因：**
在需求迭代中，为了快速上线，采用直接累加代码的方式，导致接口性能逐渐恶化。

**优化优先级：**
1. 高优（立竿见影）：批处理、异步、缓存、并行化
2. 中优：索引、SQL优化、事务控制
3. 低优（评估投入产出）：代码重构

**核心观点：**
- 站在接口设计者角度思考，在需求设计阶段考虑性能
- 预防优于治理，开发阶段考虑性能比上线后优化成本更低
- 缓存是双刃剑，需考虑数据一致性、缓存穿透、雪崩等问题

---

## 参考资料

- 原文：https://mp.weixin.qq.com/s/YBOdpV9Eh8GnIrivwPqPCA
- 作者：京东开发者
- 来源：一流职场笔记 / 今日头条

---

*整理时间：2026-02-14*
